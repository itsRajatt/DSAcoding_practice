#include<bits/stdc++.h>
using namespace std;

//stability of sorting algorithms

/*

bubble , insertion , merge stable
selection ,quick,heap unstable

bubble - O(n*n) stable , find max and swap
selection - O(n*n) unstable , select min  and swap
insertion - O(n*n) stable , in place , good for small arrays(tim and intro sort) , O(n) in best case
merge - Divide&Conquer algo, stable,O(nlogn mlogm) & O(n+m) space , good for LL in O(1) , external sorting , quick better for arrays


*/

void swap(int &a, int &b)
{
    int c=a;
    a=b;
    b=c;
}

void bubbleSort(int *arr,int n)
{
    int i, j;
    for (i = 0; i < n - 1; i++){
 
        // Last i elements are already
        // in place
        bool flag = 0; //optimied for  if array was sorted or becomes sorted
        for (j = 0; j < n - i - 1; j++){
            
                if (arr[j] > arr[j + 1])
                swap(arr[j], arr[j + 1]);
                flag =1;
        }
        
        if(flag==0) break;
    }
}

void selectSort(int *arr, int n)
{

    int i, j, min_idx;

    for (i = 0; i < n-1; i++)
    {
        min_idx = i;
        for (j = i+1; j < n; j++)
        if (arr[j] < arr[min_idx])
            min_idx = j;
 

        if(min_idx!=i)
            swap(arr[min_idx], arr[i]);
    }
}

void insertSort(int *a, int n)
{
    for(int i=1;i<n;i++)
    {
        int k=a[i];
        int j=i-1;
        while(j>=0 && a[j]>k)
        {
            a[j+1]=a[i];
            j--;
        }
        a[j+1]=k;
    }
}

void merge(int arr[], int l, int m, int h){
    
    int n1=m-l+1, n2=h-m;
    int left[n1],right[n2];
    for(int i=0;i<n1;i++)
        left[i]=arr[i+l];
    for(int j=0;j<n2;j++)
        right[j]=arr[m+1+j];    
    int i=0,j=0,k=l;
    while(i<n1 && j<n2){
        if(left[i]<=right[j])
            arr[k++]=left[i++];
        else
            arr[k++]=right[j++];
    }
    while(i<n1)
        arr[k++]=left[i++];
    while(j<n2)
        arr[k++]=right[j++];    
}

void mergeSort(int *a,int l,int r)
{
    if(r>l){
    //find mid point
    int m=l+(r-l)/2;
    mergeSort(a,l,m);
    mergeSort(a,m+1,r);
    merge(a,l,m,r);
    }
}

void ideaOfMergeSort(int *a , int *b , int n , int m)
{
   int i=0,j=0;
   
   while(i<n && j<m )
   {
       if(a[i]<=b[j]) { cout<<a[i]<<" ";
       i++;}
       else {cout<<b[j]<<" ";
       j++;}
       
       while(i<n) {cout<<a[i]<<" "; i++;}
       while(j<m) {cout<<b[j]<<" "; j++;}
   }
   
   return ;
}



int main()
{
    
    int a[]={5,7,10,11,2,3,4};
   
    mergeSort(a,0,6);
    for(int i=0;i<7;i++)
    {
        cout<<a[i]<<" ";
    }
   
    
    
    return 0;
}